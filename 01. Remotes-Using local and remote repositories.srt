1
00:00:00,000 --> 00:00:03,990
In this chapter, we're going to be looking at remote repositories, or as we call them

2
00:00:04,000 --> 00:00:05,990
in Git, simply remotes.

3
00:00:06,000 --> 00:00:10,990
In everything we've done up until now, we've been able to do just on our own computer.

4
00:00:11,000 --> 00:00:15,990
We don't even need a network connection. We can do version control just on our local files

5
00:00:16,000 --> 00:00:19,990
and not share them with anyone else, and that's very effective and Git allow us to do that.

6
00:00:20,000 --> 00:00:24,990
But Git becomes even more powerful when we're able to collaborate with others, and that's

7
00:00:25,000 --> 00:00:25,990
what remotes allow us to do.

8
00:00:26,000 --> 00:00:30,990
The concept is that there is a remote server, and we'll take our changes that we've made

9
00:00:31,000 --> 00:00:34,990
and put them on that remote server so that other people can then see them. They can then

10
00:00:35,000 --> 00:00:39,990
download the changes that we've made to their repositories, they can make changes of their

11
00:00:40,000 --> 00:00:45,990
own, upload those back to the remote server, and we can pull those back down into our repository

12
00:00:46,000 --> 00:00:46,990
to get their changes.

13
00:00:47,000 --> 00:00:52,990
It makes this remote repository sort of a central clearing house for all of these different

14
00:00:53,000 --> 00:00:57,990
changes that are going on, and that remote server is just simply a Git repository.

15
00:00:58,000 --> 00:01:02,990
Remember that Git is distributed version control. There's no real difference between the different

16
00:01:03,000 --> 00:01:07,990
repositories, so there's not a big difference between the server and our computer or the client.

17
00:01:08,000 --> 00:01:11,990
The only difference really is that the server is running some Git software that allows it

18
00:01:12,000 --> 00:01:16,990
to communicate with lots of different Git clients at the same time, but the actual repository

19
00:01:17,000 --> 00:01:20,990
where those changes are being stored, is just simply a Git repository; it has commits, it

20
00:01:21,000 --> 00:01:25,990
has branches, it has a HEAD pointer. It works exactly the same, and the fact that that Git

21
00:01:26,000 --> 00:01:30,990
repository is the central clearing house is really just a matter of convention.

22
00:01:31,000 --> 00:01:34,990
We've all just agreed that we're going to use this one repository as the place where

23
00:01:35,000 --> 00:01:39,990
we all sync up our changes, but it doesn't have to be, it's still just a Git repository.

24
00:01:40,000 --> 00:01:41,990
Let's take a look at the big picture.

25
00:01:42,000 --> 00:01:45,990
So we know that we have our computer, and we know how to have just a simple branch called

26
00:01:46,000 --> 00:01:47,990
master with commits in it.

27
00:01:48,000 --> 00:01:49,990
Now we're going to introduce a remote server.

28
00:01:50,000 --> 00:01:54,990
What we want to do is take our commits and put them on the remote server, so other people can see them.

29
00:01:55,000 --> 00:01:59,990
The process that we used to do that is called a push. So we push our changes to the remote

30
00:02:00,000 --> 00:02:02,990
server, or you can say you pushed them up to the remote server.

31
00:02:03,000 --> 00:02:07,990
At that point, the remote server creates the same branch with the same commits with the

32
00:02:08,000 --> 00:02:12,990
exact same commit IDs referring to all of them, at that point our collaborators have

33
00:02:13,000 --> 00:02:15,990
the ability to see our commits.

34
00:02:16,000 --> 00:02:21,990
At the same time, Git also makes another branch on our local computer that is typically called

35
00:02:22,000 --> 00:02:23,990
origin slash and then whatever the branch name is.

36
00:02:24,000 --> 00:02:27,990
Now that's by convention, we'll talk about how we can change that name, it doesn't have

37
00:02:28,000 --> 00:02:30,990
to be origins, but in this case we'll stick with the default.

38
00:02:31,000 --> 00:02:36,990
So origin/master is a branch on our local machine that references the remote server

39
00:02:37,000 --> 00:02:41,990
branch, and it always tries to stay and sync with that. Right now it looks like all three

40
00:02:42,000 --> 00:02:44,990
of them are in sync, but it doesn't always have to be that way.

41
00:02:45,000 --> 00:02:48,990
We continue developing, we makes some more commits on our master branch when we're ready

42
00:02:49,000 --> 00:02:53,990
to share those commits, again, we do a push, so we push that code up to the remote server,

43
00:02:54,000 --> 00:02:58,990
and it makes note of the change also in our origin/master branch, the one that tries to

44
00:02:59,000 --> 00:03:00,990
stay in sync with the remote one.

45
00:03:01,000 --> 00:03:04,990
When other people make changes to the remote server and contribute them there, we need to

46
00:03:05,000 --> 00:03:08,990
pull those changes down so that we know about them, and the way that we do that is with

47
00:03:09,000 --> 00:03:10,990
what's called a fetch.

48
00:03:11,000 --> 00:03:15,990
So we fetch the changes, at that point they come into our origin master branch, because

49
00:03:16,000 --> 00:03:19,990
what we're doing is keeping those in sync. Fetch is essentially saying sync up my origin

50
00:03:20,000 --> 00:03:25,990
master with the remote server version, but it does not bring it into our master branch.

51
00:03:26,000 --> 00:03:30,990
Now our computer knows about the change, we have it locally, if we get on an airplanes

52
00:03:31,000 --> 00:03:34,990
and fly somewhere while we're on the airplane, we'll have a copy of that commit that 923ea,

53
00:03:35,000 --> 00:03:40,990
but it won't be in our master branch until we do a merge, and at that point then it'll

54
00:03:41,000 --> 00:03:42,990
be brought in to our master branch, and we'll be back in sync.

55
00:03:43,000 --> 00:03:46,990
Now this is an over simplified example, because you might notice that on my computer I have

56
00:03:47,000 --> 00:03:48,990
lots of duplicates.

57
00:03:49,000 --> 00:03:52,990
You can see that I have those same Git objects listed twice on my own computer.

58
00:03:53,000 --> 00:03:56,990
In realty, it doesn't store them twice. Git is smart about reusing these objects, because

59
00:03:57,000 --> 00:03:58,990
they're exactly the same.

60
00:03:59,000 --> 00:04:02,990
So Git uses pointers instead, to point to that, and we know about the HEAD pointer.

61
00:04:03,000 --> 00:04:05,990
So let's take a quick look at how that works just to make sure that that's clear.

62
00:04:06,000 --> 00:04:10,990
I think for illustrative purposes, it was good to see it as two separate branches with

63
00:04:11,000 --> 00:04:11,990
two sets of commits.

64
00:04:12,000 --> 00:04:17,990
But in reality, we have a HEAD pointer for master that points to the third commit, when

65
00:04:18,000 --> 00:04:21,990
we do a push and push it through remote server, it creates the commits there, and moves the

66
00:04:22,000 --> 00:04:27,990
HEAD pointer for master to the third commit, and then also adds another pointer that points

67
00:04:28,000 --> 00:04:32,990
to the same commit on our local computer. It doesn't actually duplicate those three objects.

68
00:04:33,000 --> 00:04:37,990
When we then make a new commit, it moves our master pointer to the commit, when we do a

69
00:04:38,000 --> 00:04:43,990
push it creates that new object on the remote server and moves the pointer, and also increments origin/master.

70
00:04:44,000 --> 00:04:48,990
Then when new changes come into the remote server from someone else, of course, it moves

71
00:04:49,000 --> 00:04:51,990
the master pointer to point to that latest commit.

72
00:04:52,000 --> 00:04:57,990
When we do a fetch, it brings that new Git object down onto our computer and moves the

73
00:04:58,000 --> 00:05:02,990
origin pointer to point to it, but our master ones still doesn't. We have to first do a

74
00:05:03,000 --> 00:05:06,990
merge, and we know that would be a fast- forward merge, that's what we would call that, in

75
00:05:07,000 --> 00:05:09,990
this case where it just moves all the way to point to the same commit.

76
00:05:10,000 --> 00:05:14,990
So as you can probably see, origin/master really is just a branch, it's just like the

77
00:05:15,000 --> 00:05:15,990
other branches that we're working with.

78
00:05:16,000 --> 00:05:20,990
The only difference is that it tries to stay in sync with what's on the remote server.

79
00:05:21,000 --> 00:05:25,990
The reason that matters is because it is possible for someone to make a commit on the remote

80
00:05:26,000 --> 00:05:29,990
server while we're in the process of making a commit on our local machine.

81
00:05:30,000 --> 00:05:34,990
All right, it happens all the time. I'm making changes to one part of the project, my collaborator

82
00:05:35,000 --> 00:05:39,990
is making changes to their part of the project, they put theirs up on the remote server, my

83
00:05:40,000 --> 00:05:44,990
origin master, once I do a fetch, the state of our two servers would look something like this.

84
00:05:45,000 --> 00:05:49,990
You'll see that origin/master does still include those objects that are in the remote branch,

85
00:05:50,000 --> 00:05:55,990
it did stay in sync with that, but in the meantime I've got a new commit called ba8ce.

86
00:05:56,000 --> 00:06:00,990
So now that our two branches have diverged, we need to do a merge to bring them back together

87
00:06:01,000 --> 00:06:04,990
again, and that process works exactly the same way as we saw when we were working with

88
00:06:05,000 --> 00:06:08,990
emerging branches. Origin/master is just a branch, so we can merge them together and

89
00:06:09,000 --> 00:06:13,990
then the next time we do a push, our master changes will be merged in and sent off to

90
00:06:14,000 --> 00:06:14,990
the remote server.

91
00:06:15,000 --> 00:06:19,990
So generally speaking, the process that you go through when you're working with a remote,

92
00:06:20,000 --> 00:06:23,990
is that you'll do your commits locally, then you'll fetch the latest from the remote server,

93
00:06:24,000 --> 00:06:28,990
get your origin branch in sync, then merge any of the new work you did into what just

94
00:06:29,000 --> 00:06:32,990
came down from the server and then push the result back up to the remote server.

95
00:06:33,000 --> 00:06:37,990
If the process seems at all unclear now, it'll become second nature soon enough.

96
00:06:38,000 --> 00:06:48,000


